策划文档

概述：
1.这是一款基于roblox的游戏，玩家通过在商店购买兵种，然后合成兵种后，获得更强力的兵，并且通过获得的兵种去战斗，以获得更多的金币

大概的玩法是：玩家在商店购买兵种，通过兵种合成，将兵种放在地上，让地上的兵种自动去挑战关卡，然后玩家获得更多的金币
在开发的过程中要考虑好整体架构
游戏大概一个服务器6名玩家，每个玩家根据服务器分配出现在对应的出生点上
在出生点上出生后，要加载玩家的货币数据以及已经拥有的兵种的数据，在场地上生成对应的内容，这部分下面会详细讲解

接下来我们将有序按照版本顺序进行开发，最终实现该游戏的开发

V1.0版本

货币系统定义：
1.我们在游戏中定义一种货币：金币
2.金币可以通过各种渠道来获得，比如战斗/挂机/付费购买等，这些我们在后面的开发过程中会逐步补充，当前版本只需要完成金币的定义
3.玩家的初始金币数量为100

关于金币数量的显示
StarterGui - MainGui - CoinNum是一个Textlabel，用于显示玩家的金币数量
玩家金币数量显示需要实时更新，每当玩家的金币数发生变化的时候都需要进行更新
金币的显示格式为：$XXXXX ，其中XXXXX为玩家的当前的金币数量

在开发过程中，要为以后的金币数量获得预留好接口设计好架构，获得金币的渠道有：
1.玩家通过主线关卡挑战来获得金币
2.玩家通过挂机机制来获得金币
3.玩家通过购买开发者产品来获得金币

玩家基地定义：

在我们的游戏中，设定每个服务器最多6名玩家
每个玩家在游戏中都有属于自己的基地，在玩家进入游戏后，系统随机将玩家分配到游戏内的6个基地之一作为玩家的基地并加载玩家的数据

在游戏中，workspace下，有个文件夹叫Home，是所有玩家的整体信息的总文件夹，其下有PlayerHome1到PlayerHome2共6个文件夹，分别用于承载6个玩家的基地信息
下面以PlayerHome1为例子进行举例：
    PlayerHome1下有个SpawnLocation，如果玩家进来时系统将其分配为了1号玩家，则该玩家就出生在PlayerHome1下的SpawnLocation

    目前先实现到这个级别，其他功能我们后续慢慢开发即可

    注意：玩家的位置分配是从1到6的空位中随机一个，而不是按顺序固定1到6排序


V1.1
兵种定义与实现：

兵种类型
兵种攻击方式

我们在游戏中定义多种类型的兵种，作为我们游戏中的“战斗角色”

兵种最基础分类为：近战单位和远程单位
我们会有各种包装类型的兵种，但是本质上就是近战单位与远程单位的区别

士兵有等级区分，从1级到6级
每个兵种都有属于自己的模型，兵种模型放在ReplicatedStorage中，我会给每个兵种配置对应的模型路径，代码需要支持根据我配置的路径去寻找模型
每当我购买获得通过其他方式获得了一个兵种，就从路径下复制一个模型作为表现，然后根据数据生成一个兵

每个兵种可以通过商店来进行购买，购买时需要花费玩家的金币，购买成功时会获得该兵种的1个基础1级兵
每个兵种根据体型大小，会有占地格子数的区分，有些兵种只占据1个格子，有些兵种会占据4个格子

下面我们举个例子：
兵种1：
    名字：Noob
    模型路径：ReplicatedStorage/Role/Basic/Noob
    类型：近战
    基础等级：1级
    购买价格：100（这里指金币）
    占地面积：1格

兵种2：
    Rookie
    类型：近战
    模型路径：ReplicatedStorage/Role/Basic/Rookie
    基础等级：1级
    购买价格：200（这里指金币）
    占地面积：1格


我们需要一张专门的士兵表，用来配置士兵类型，支持我拓展不同的兵种

其实购买兵种时，就是获得一个对应的兵种，玩家可以同时有多个相同的兵种，比如有3个Noob，2个Rookie等

关于兵种的获得：

1.这个版本我们暂时不开发兵种的购买功能，我们通过命令行工具用gm命令来测试兵种的获得
2.兵种购买完成后，需要暂时先放在我们的背包中（暂定放在背包中即可），其实可以理解为兵种就是一个商品道具，兵种放在背包中暂定就用名字显示在背包里即可


V1.2 兵种放置

基本功能描述：每个玩家都有一块基础地板，玩家可以将背包中的兵种放在地板上，但是也只能放在地板上，不能放在其他地方

放置地板定义：

每个玩家的家园中都有一个叫IdleFloor的Part，是用来放置兵种的地板，兵种只可以放在该Part上
以PlayerHome1举例，IdleFloor的路径是Workspace - Home - PlayerHome1 - IdleFloor
IdleFloor是由14*14个基础大小的studs组成的，我们在配置表中说的兵种的占地面积就是指占据多少个studs，占据1格就是1*1studs，占地4格就是2*2studs，占地9格就是3*3studs
IdleFloor的大小是标准的120, 1, 120，做摆放范围限制时可以用studs大小限制也可以获取IdleFloor的中心坐标，然后根据大小来做范围限制

地板格子定义：
1.每个studs是一个基础放置单位，每个模型只能占据1或者4或者9个studs
2.模型放下去后，就以studs的中心做为模型HumanoidRootPart的放置点，总之就是把模型放在所属格子的中心


放置流程：
1.选中兵种
2.在地板上出现兵种（此时还可移动，并未真正放下），此时可定义为：放置中
3.放置完成，从背包扣除该兵种数量，并真正放置在地板上，视为放置完成。

选中兵种：
主要是通过点击背包中的兵种信息来完成选中
这里有一点要注意：我们现在的背包中的兵种看起来不支持点击，这里要改成能点击能选中

放置操作（电脑端）：
1.玩家点击背包中的兵种，触发摆放操作
2.在鼠标处出现选中的兵种的模型，出现时有几个表现需要特殊实现：
    a.出现的兵种需要有高光，具体逻辑是：每个兵种模型下都有一个Highlight，高光就是把Highlight的颜色改成0, 255, 0，把Highlight的filltransparency改成0.4
3.玩家点击鼠标左边，触发确认操作，此时彻底把模型放在所属的地板上，放置完成；但是如果玩家点击鼠标左键，则视为取消放置，从鼠标端移除模型，结束本次放置操作


放置操作（移动端）
1.玩家点击背包中的兵种，触发摆放操作
2.在玩家当前角色朝向前3studs的位置，出现兵种的模型，进入放置中的状态
3.玩家可通过手指拖动模型来确定要摆放模型的位置
4.在模型放置过程中，需要显示出ui：将StarterGui - PutConfirm的Enable属性改成True
5.玩家点击tarterGui - PutConfirm - ButtonBg - Confirm按钮，视为确认放置，将模型成功放置在地上，并且结束放置流程，并隐藏ui：将StarterGui - PutConfirm的Enable属性改成false
6.玩家点击tarterGui - PutConfirm - ButtonBg - Cancel按钮，视为取消放置，将模型移除，并结束放置流程，并隐藏ui：将StarterGui - PutConfirm的Enable属性改成false


放置范围：
我们设定兵种只能放在IdleFloor上，不能超出放置范围，以及在放置阶段鼠标就算移出IdleFloor范围，兵种也不能跟着移出去，最多到IdleFloor边上，移动时贴着IdleFloor的边移动，类似空气墙撞墙那种效果


吸地的逻辑：
由于我们的兵种占地格子是标准的studs，而不是随便摆放，所以我们的兵种在放置阶段的时候，拖动鼠标或者手指拖动位置时需要有吸附效果
具体的吸附逻辑是：
    1.玩家在移动兵种过程中，如果松手时，兵种没有放在正好的占地studs中心，则需要把模型强制移动到模型中心放下，看起来是被吸附到了位置上
    2.在用鼠标或者手指移动的过程中，不要做成实时模型跟着移动，要去判断鼠标或手指的位置，看鼠标或者手指的位置离哪个studs中心近，如果还是离当前的studs单位更近，模型保持不动，如果鼠标移动到离边上的studs更近，则要立刻把模型吸附过去
    3.鼠标或手指移动的过程中，看起来就是模型一顿一顿被吸附着移动的，而不是自然而然流畅的线性移动


功能修改：
我修改下我在策划案中关于studs的表述，我的表述是有问题的，我的一个兵种占据
  的格子其实是由一个4*4的studs组成的，也就是16个studs组成的正方形，2*2的格子其实是8*8的共64个Studs组成的，3*3的格子其
  实是12*12共144个Studs组成的

V1.2.1
补充关于兵种放置相关的需求：

放置表现修改：
1.放置兵种时，将现在HighLight的修改FillColor的颜色改为修改OutlineColor的颜色，色号不变依然是0, 255, 0，也就是我们不改FillColor的颜色了，变成改OutlineColor的颜色
2.去除现在的HighLight的修改FillTransparency的逻辑，保持默认值即可
3.放置结束后，取消HighLight的效果

放置表现补充：
1.放置过程中，需要在兵种当前脚底的格子上，盖一层Part
2.根据模型当前的吸附效果所属的格子，从Workspace - Grid中去复制一个对应的Part盖在格子上
3.占地1*1的模型，去复制Workspace - Grid - GridGreen1，占地2*2的模型，去复制Workspace - Grid - GridGreen2，占地3*3的模型，去复制Workspace - Grid - GridGreen2，占地3
4.复制出来的Grid的Part需要根据模型的位置实时变化，模型到哪里，Grid下的Part就跟着移动到哪里
5.当放置完成后，再移除复制出来的Grid的Part
6.其实就是给模型脚底放一个用来凸显位置的发光小块

位置冲突：
1.放置模型时，我们现有的逻辑是：同一个格子上无法放置两个模型，这个逻辑没错，我们现在要加入相关的表现
2.在放置过程中，如果模型当前的位置与其他已经放置了模型的位置重叠了，那走跟上面一样的表现逻辑，也是去Grid下复制模型，只不过复制的分别是GridRed1/GridRed2/GridRed3
3.这两种应该是实时切换的，我当前的位置支持放下去，就是绿色的Grid，如果发现位置冲突无法放下，就需要把绿色的Grid换成红色的Grid,然后我又挪开后发现又支持放下去了，就再改成绿色的Grid

