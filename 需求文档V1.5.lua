策划文档

概述：
1.这是一款基于roblox的游戏，玩家通过在商店购买兵种，然后合成兵种后，获得更强力的兵，并且通过获得的兵种去战斗，以获得更多的金币

大概的玩法是：玩家在商店购买兵种，通过兵种合成，将兵种放在地上，让地上的兵种自动去挑战关卡，然后玩家获得更多的金币
在开发的过程中要考虑好整体架构
游戏大概一个服务器6名玩家，每个玩家根据服务器分配出现在对应的出生点上
在出生点上出生后，要加载玩家的货币数据以及已经拥有的兵种的数据，在场地上生成对应的内容，这部分下面会详细讲解

接下来我们将有序按照版本顺序进行开发，最终实现该游戏的开发

V1.0版本

货币系统定义：
1.我们在游戏中定义一种货币：金币
2.金币可以通过各种渠道来获得，比如战斗/挂机/付费购买等，这些我们在后面的开发过程中会逐步补充，当前版本只需要完成金币的定义
3.玩家的初始金币数量为100

关于金币数量的显示
StarterGui - MainGui - CoinNum是一个Textlabel，用于显示玩家的金币数量
玩家金币数量显示需要实时更新，每当玩家的金币数发生变化的时候都需要进行更新
金币的显示格式为：$XXXXX ，其中XXXXX为玩家的当前的金币数量

在开发过程中，要为以后的金币数量获得预留好接口设计好架构，获得金币的渠道有：
1.玩家通过主线关卡挑战来获得金币
2.玩家通过挂机机制来获得金币
3.玩家通过购买开发者产品来获得金币

玩家基地定义：

在我们的游戏中，设定每个服务器最多6名玩家
每个玩家在游戏中都有属于自己的基地，在玩家进入游戏后，系统随机将玩家分配到游戏内的6个基地之一作为玩家的基地并加载玩家的数据

在游戏中，workspace下，有个文件夹叫Home，是所有玩家的整体信息的总文件夹，其下有PlayerHome1到PlayerHome2共6个文件夹，分别用于承载6个玩家的基地信息
下面以PlayerHome1为例子进行举例：
    PlayerHome1下有个SpawnLocation，如果玩家进来时系统将其分配为了1号玩家，则该玩家就出生在PlayerHome1下的SpawnLocation

    目前先实现到这个级别，其他功能我们后续慢慢开发即可

    注意：玩家的位置分配是从1到6的空位中随机一个，而不是按顺序固定1到6排序


V1.1
兵种定义与实现：

兵种类型
兵种攻击方式

我们在游戏中定义多种类型的兵种，作为我们游戏中的“战斗角色”

兵种最基础分类为：近战单位和远程单位
我们会有各种包装类型的兵种，但是本质上就是近战单位与远程单位的区别

士兵有等级区分，从1级到6级
每个兵种都有属于自己的模型，兵种模型放在ReplicatedStorage中，我会给每个兵种配置对应的模型路径，代码需要支持根据我配置的路径去寻找模型
每当我购买获得通过其他方式获得了一个兵种，就从路径下复制一个模型作为表现，然后根据数据生成一个兵

每个兵种可以通过商店来进行购买，购买时需要花费玩家的金币，购买成功时会获得该兵种的1个基础1级兵
每个兵种根据体型大小，会有占地格子数的区分，有些兵种只占据1个格子，有些兵种会占据4个格子

下面我们举个例子：
兵种1：
    名字：Noob
    模型路径：ReplicatedStorage/Role/Basic/Noob
    类型：近战
    基础等级：1级
    购买价格：100（这里指金币）
    占地面积：1格

兵种2：
    Rookie
    类型：近战
    模型路径：ReplicatedStorage/Role/Basic/Rookie
    基础等级：1级
    购买价格：200（这里指金币）
    占地面积：1格


我们需要一张专门的士兵表，用来配置士兵类型，支持我拓展不同的兵种

其实购买兵种时，就是获得一个对应的兵种，玩家可以同时有多个相同的兵种，比如有3个Noob，2个Rookie等

关于兵种的获得：

1.这个版本我们暂时不开发兵种的购买功能，我们通过命令行工具用gm命令来测试兵种的获得
2.兵种购买完成后，需要暂时先放在我们的背包中（暂定放在背包中即可），其实可以理解为兵种就是一个商品道具，兵种放在背包中暂定就用名字显示在背包里即可


V1.2 兵种放置

基本功能描述：每个玩家都有一块基础地板，玩家可以将背包中的兵种放在地板上，但是也只能放在地板上，不能放在其他地方

放置地板定义：

每个玩家的家园中都有一个叫IdleFloor的Part，是用来放置兵种的地板，兵种只可以放在该Part上
以PlayerHome1举例，IdleFloor的路径是Workspace - Home - PlayerHome1 - IdleFloor
IdleFloor是由14*14个基础大小的studs组成的，我们在配置表中说的兵种的占地面积就是指占据多少个studs，占据1格就是1*1studs，占地4格就是2*2studs，占地9格就是3*3studs
IdleFloor的大小是标准的120, 1, 120，做摆放范围限制时可以用studs大小限制也可以获取IdleFloor的中心坐标，然后根据大小来做范围限制

地板格子定义：
1.每个studs是一个基础放置单位，每个模型只能占据1或者4或者9个studs
2.模型放下去后，就以studs的中心做为模型HumanoidRootPart的放置点，总之就是把模型放在所属格子的中心


放置流程：
1.选中兵种
2.在地板上出现兵种（此时还可移动，并未真正放下），此时可定义为：放置中
3.放置完成，从背包扣除该兵种数量，并真正放置在地板上，视为放置完成。

选中兵种：
主要是通过点击背包中的兵种信息来完成选中
这里有一点要注意：我们现在的背包中的兵种看起来不支持点击，这里要改成能点击能选中

放置操作（电脑端）：
1.玩家点击背包中的兵种，触发摆放操作
2.在鼠标处出现选中的兵种的模型，出现时有几个表现需要特殊实现：
    a.出现的兵种需要有高光，具体逻辑是：每个兵种模型下都有一个Highlight，高光就是把Highlight的颜色改成0, 255, 0，把Highlight的filltransparency改成0.4
3.玩家点击鼠标左边，触发确认操作，此时彻底把模型放在所属的地板上，放置完成；但是如果玩家点击鼠标左键，则视为取消放置，从鼠标端移除模型，结束本次放置操作


放置操作（移动端）
1.玩家点击背包中的兵种，触发摆放操作
2.在玩家当前角色朝向前3studs的位置，出现兵种的模型，进入放置中的状态
3.玩家可通过手指拖动模型来确定要摆放模型的位置
4.在模型放置过程中，需要显示出ui：将StarterGui - PutConfirm的Enable属性改成True
5.玩家点击tarterGui - PutConfirm - ButtonBg - Confirm按钮，视为确认放置，将模型成功放置在地上，并且结束放置流程，并隐藏ui：将StarterGui - PutConfirm的Enable属性改成false
6.玩家点击tarterGui - PutConfirm - ButtonBg - Cancel按钮，视为取消放置，将模型移除，并结束放置流程，并隐藏ui：将StarterGui - PutConfirm的Enable属性改成false


放置范围：
我们设定兵种只能放在IdleFloor上，不能超出放置范围，以及在放置阶段鼠标就算移出IdleFloor范围，兵种也不能跟着移出去，最多到IdleFloor边上，移动时贴着IdleFloor的边移动，类似空气墙撞墙那种效果


吸地的逻辑：
由于我们的兵种占地格子是标准的studs，而不是随便摆放，所以我们的兵种在放置阶段的时候，拖动鼠标或者手指拖动位置时需要有吸附效果
具体的吸附逻辑是：
    1.玩家在移动兵种过程中，如果松手时，兵种没有放在正好的占地studs中心，则需要把模型强制移动到模型中心放下，看起来是被吸附到了位置上
    2.在用鼠标或者手指移动的过程中，不要做成实时模型跟着移动，要去判断鼠标或手指的位置，看鼠标或者手指的位置离哪个studs中心近，如果还是离当前的studs单位更近，模型保持不动，如果鼠标移动到离边上的studs更近，则要立刻把模型吸附过去
    3.鼠标或手指移动的过程中，看起来就是模型一顿一顿被吸附着移动的，而不是自然而然流畅的线性移动


功能修改：
我修改下我在策划案中关于studs的表述，我的表述是有问题的，我的一个兵种占据
  的格子其实是由一个4*4的studs组成的，也就是16个studs组成的正方形，2*2的格子其实是8*8的共64个Studs组成的，3*3的格子其
  实是12*12共144个Studs组成的

V1.2.1
补充关于兵种放置相关的需求：

放置表现修改：
1.放置兵种时，将现在HighLight的修改FillColor的颜色改为修改OutlineColor的颜色，色号不变依然是0, 255, 0，也就是我们不改FillColor的颜色了，变成改OutlineColor的颜色
2.去除现在的HighLight的修改FillTransparency的逻辑，保持默认值即可
3.放置结束后，取消HighLight的效果

放置表现补充：
1.放置过程中，需要在兵种当前脚底的格子上，盖一层Part
2.根据模型当前的吸附效果所属的格子，从Workspace - Grid中去复制一个对应的Part盖在格子上
3.占地1*1的模型，去复制Workspace - Grid - GridGreen1，占地2*2的模型，去复制Workspace - Grid - GridGreen2，占地3*3的模型，去复制Workspace - Grid - GridGreen2，占地3
4.复制出来的Grid的Part需要根据模型的位置实时变化，模型到哪里，Grid下的Part就跟着移动到哪里
5.当放置完成后，再移除复制出来的Grid的Part
6.其实就是给模型脚底放一个用来凸显位置的发光小块

位置冲突：
1.放置模型时，我们现有的逻辑是：同一个格子上无法放置两个模型，这个逻辑没错，我们现在要加入相关的表现
2.在放置过程中，如果模型当前的位置与其他已经放置了模型的位置重叠了，那走跟上面一样的表现逻辑，也是去Grid下复制模型，只不过复制的分别是GridRed1/GridRed2/GridRed3
3.这两种应该是实时切换的，我当前的位置支持放下去，就是绿色的Grid，如果发现位置冲突无法放下，就需要把绿色的Grid换成红色的Grid,然后我又挪开后发现又支持放下去了，就再改成绿色的Grid


V1.3 兵种回收

我们在基地上放下的兵种，支持再收回背包中

具体逻辑是:
1.玩家点击StarterGui - MainGui - Remove这个按钮，触发回收流程：
2.回收流程下：需要：
    a.自动将背包按钮切换为显示状态，同时将MainGui - Start的visible属性改成false，将MainGui - CoinNum的visible属性也改成False
    b.将StarterGui - MainGui-RemoveTips的Visible属性改成True
    c.将StarterGui - MainGui - Remove的Visible属性改成false
    d.将StarterGui - MainGui - Exit的Visible属性改成True

3.玩家点击Exit按钮，或者当场中没有任何一个摆放中的兵种模型时，退出回收流程，退出回收流程后：
    a.将StarterGui - MainGui - Exit的Visible属性改成false
    b.将StarterGui - MainGui-RemoveTips的Visible属性改成false
    c.将StarterGui - MainGui - Remove的Visible属性改成true
    d.自动将背包按钮切换为隐藏状态，同时将MainGui - Start的visible属性改成true，将MainGui - CoinNum的visible属性也改成true

回收操作：
在回收流程中时，玩家点击场中已经摆放的模型，可以将该模型从场中移除，释放出占据的位置，并将该模型收回到自己的背包中
回收状态下点击模型时，需要将模型的HighLight的描边改成红色

注意：在回收状态下，点击背包中的兵种信息，无法触发摆放操作，一定要退出回收模式，才能点击背包中的兵种信息触发摆放操作


V1.4 兵种属性设定

我们给兵种定义集中属性：
基础攻击力：决定基础伤害
基础生命值：决定基础的存活能力
基础攻击速度：决定每完成一次普攻需要的时间

另外我们会定义兵种等级：兵种基础等级为1级，可以提升兵种等级，最高等级为3级

兵种的生命值与攻击力会随着等级提升而提升，在等级提升后，数值会有相应的提升
具体计算逻辑是：
兵种属性=1级时属性*等级*等级系数

1级的等级系数是1，二级的等级系数是1.2，3级的等级系数是1.5
也就是比如1级攻击力是100，2级就是100*2*1.2=240，3级就是100*3*1.5=450

兵种等级显示：
在每个兵种的模型下，有个Head模型，其下有个叫BillboardGui的BillboardGui，其下有个叫TextLabel用于显示兵种当前的等级，格式是：Lv.X，注意：如果达到了最高级，这里显示的是Lv.Max

兵种升级：
两个相同等级的同UnitId兵种，可以合成成一个更高等级的同UnitId兵种
比如两个1级Rookie，可以合成一个2级的Rookie

合成兵种等级有上限限制，最高等级到3级，3级就无法再合成

合成操作：
玩家直接拖动场上的兵种，拖动到另一个同等级同UnitId的兵种的位置，保持位置重叠，松手（或者送鼠标）后，进行合成判断

合成预览：
1.如果两个兵种满足合成条件，则在把A拖动到B时，在B的位置复制Grid下的GridGreen1或者GridGreen2或者GridGreen3，这一块的逻辑参考摆放兵种时的兵种脚底的GridGreen或GridRed的Part的显示逻辑即可
2.如果不满足合成条件，则A拖动到B的时候，在B脚底显示的是红色的GridRed


如果满足合成条件，则：
    1.移除原来的两个基础兵种
    2.在当前位置生成一个更高一级的同UnitId的兵种

如果不满足合成条件，则：
    1.系统飘字提示：无法合成
    2.将拖过来的兵种，移动回拖动前的位置

V1.4.1补充需求：

1.在玩家拖动兵种模型的时候，我需要把兵种模型的高度稍微抬高一点，看起来是被拔起来了，这个参数我希望可以我自己调整
2.在合成新的兵种或者回归原位时，再恢复原来的高度

3.在玩家拖动的过程中，我希望把兵种的HighLight的描边改成绿色，在放下或者回归原位时再恢复为默认状态
4.如果把A放在B身上，二者不符合合成条件时，不光要在B脚底出现Grid的红色GridRed，也要把A的HighLight描边改成红色

我们这里补充一下关于默认状态下的HighLight的描边的状态：
默认状态下，也就是模型被放在地上的状态，模型的描边应该是透明度为1，在拖动时或者摆放时，才把描边的透明度改成0，只要放在地上完成了，就该把描边透明度改为1


另外我需要补充一个逻辑：
我们现在拖动模型到一个空位的时候，是无法完成换位置的，但是我希望这个效果是可以实现的
也就是我可以把A拖动放到一个空位处

所以这里我们的拖动时候的需求就统一变成：
1.只要拖动，就把模型抬高，并且脚底有出现绿色的Grid的Part，同时角色身上有绿色描边
2.如果是拖动换位置，那和我们摆放模型时的流程是一样的，就当重新进入了摆放模型的流程
3.如果是合成，拖动到目标兵种上后，还是要保持我们的如果不满足合成条件脚底就是红色并且身上是红色HighLight描边，松手后回原位

再次补充：我们移除了拖动时抬高角色的机制，改为不抬高

V1.5 战斗系统构建

战斗系统构建：
概述：
我们将会构建一套基础的战斗系统，我们的战斗是由玩家的小兵与关卡中的小兵之间根据AI逻辑自动进行战斗，而不是玩家之间互相战斗

战斗基础部分：

基础属性定义：
在我们之前的玩家属性定义部分已经增加了相关的定义，这里再次说明，我们的兵种共分4类基础属性：
攻击力：决定了在战斗时会对敌方造成多少伤害
血量：决定了兵种的生存能力
攻击速度，决定了在战斗时，兵种多久进行一次基础的普通攻击
攻击距离：决定了兵种离目标多远时开始发动普攻
移动速度：决定了兵种在场上的奔跑速度
以上属性都要在兵种的配置表中体现出来，由字段进行控制

伤害公式：造成的伤害值=攻击方的基础攻击力
比如某个兵种基础攻击力是100，那么攻击了敌方1次后，将会扣除敌方100点血量

伤害流程：
1.如果是近战，需要判定角色的手中的攻击武器是否与目标的身体完成了接触，如果完成了接触，视为攻击生效，则走伤害公式计算出本次伤害，然后给敌方扣除对应的血量
2.如果是远程，需要判定角色发射出的子弹弹道是否与敌方身体完成了接触，如果完成了接触，则视为攻击生效，则走伤害公式计算出本次伤害，然后给敌方扣除对应的血量
3.不论是近战还是远程，都是在武器或者弹道与敌方身体发生接触的时候进行扣血

死亡流程：
当兵种的血量小于等于0时，兵种立刻死亡：播放死亡动作，并在战斗场景中消失

攻击目标寻找：
1.战斗开始后，攻击角色需要立刻寻找一圈场上的敌方单位，锁定一个直线距离离自己最近的敌方单位，开始朝目标移动，移动时根据自己的移动速度进行移动
2.在移动过程中，当角色判定攻击目标与自己之间的直线距离小于自己的攻击距离时，就立刻停下来移动，开始对目标进行普通攻击
3.在每次攻击之前，都需要判定一次目标与自己之间的距离，如果双方距离大于攻击距离，则要继续移动到目标身边直至进入自己的攻击距离内，才能停下来进行普通攻击
4.在每次普攻之前，也需要进行另一层的判断，就是对方是否已经死亡，如果判定敌方已经死亡，则去继续寻找下一个距离自己最近的目标，并开始朝目标移动并在符合条件的情况下进行普通攻击
5.也就是流程是寻找目标→确定目标→判定双方距离是否在攻击范围内→如果不是就朝目标移动/如果是就开始普攻
6.关于敌方死亡的判断，需要在目标死亡的瞬间发送通知给攻击方，这样攻击方可以收到信号停止进攻并开始寻找新的攻击目标
7.如果场中已经没有可以寻找到的攻击单位，则进入待机流程
8.如果在朝目标移动过程中遇到了障碍物，则要始终持续保持寻路，直至对方死亡切换目标或彻底找不到新的攻击目标
9.兵种移动就播放角色身上默认的移动动画即可

普攻流程：
（这里讲的是已经进入攻击范围内后符合攻击条件下已经触发普通攻击时的攻击流程）
1.近战：原地站定，并播放普通攻击动画，普通攻击动画id需要在兵种表中进行配置；
2.远程：原地站定，并播放普通攻击动画，普通攻击动画id需要在兵种表中进行配置
注意，远程单位攻击时，需要从自己的武器中发射出子弹，子弹需要飞向目标，远程单位的弹道飞行速度在兵种表中需要添加一个配置来控制。近战单位的这个属性填0即可，远程单位的这个值填的数值，代表发射出来的子弹在场中的飞行距离。并且有个重要的点是：远程单位发射出来的子弹不与非目标进行碰撞，只与目标进行碰撞，理论上子弹可以穿过所有的非目标单位的身体。
远程单位的弹道是始终追踪目标单位的，举个极端点的例子，目标单位在场中做S型移动，那么弹道也会始终朝他的位置移动，也就是只要没追到目标，就会始终朝目标移动，类似跟踪炮弹一样

基础战斗测试模块需求：
我需要在游戏中对我们的战斗系统进行测试调试，所以需要一套简易的战斗系统调试工具，具体需求是：
我在游戏中的Workspace下新建了一个文件夹，叫做：BattleTest，这个文件夹下有两个子文件夹叫Attack以及Defense。Attack下有5个Part，分别是Position1到Position5，在Defense下也有5个Part，分别是Position1到Position5。以上的两个文件夹是用来在测试战斗的时候攻击方的兵种生成位置以及防守方的兵种生成位置，每个Position都有坐标信息，生成时直接获取PositionX的坐标信息在对应坐标处生成兵种即可

兵种的碰撞：
兵种之间是需要有碰撞的吗，敌方兵种与我方兵种及我方兵种和我方兵种之间都需要有碰撞

需要创建一套简易的UI，用来生成对战的兵种，里面大概的信息有：
1.进攻方/还是防守方的选择列表
2.可用的兵种列表（配置表中有的兵种都算进来）
3.生成的位置（position1到Position5可选）
4.生成的等级，也是下来列表，最多从1级到3级可选
以上四个都是下拉式列表，三个选择完的信息共同组成一个兵种的生成信息，包括位置、兵种、等级、攻击方还是防守方

然后在简易UI上，有个开始按钮，点击开始后，兵种开始进行战斗。在战斗过程中，直至有一方全部死亡完后，战斗结束，并且等待3秒后，将场中生成的测试兵种移除

简易UI需要有个快捷打开与关闭的方式，使用键盘V键，打开简易战斗调试UI

注意我们的战斗逻辑：一个服务器有多个玩家，每个玩家都有自己的兵种，每个玩家都可以让自己的兵种去进行战斗。所以极限情况下多个玩家都在同时进行自己的战斗
我们的服务器最多同时承载8个玩家


V1.5.1补充修改

关于近战逻辑的一些调整优化：

1.不要完全依赖 Touched
    Touched 在多人/高并发场景下不稳定（重复触发、漏触发、靠物理帧），且容易被客户端篡改或被网络延迟影响。更适合用于物理交互而非判定伤害的最终来源。
2.推荐：动作标记（Animation Marker） + 服务端判定（距离/射线/重叠）
    在攻击动画里放一个 Hit 标记（Animation Event / AnimationTrack:GetMarkerReachedSignal），当标记触发时由服务器计算是否命中：
    检查目标是否仍存活；
    检查距离（<= 攻击距离 + 宽容值）；
    可选：射线检测（Raycast）或形状重叠（Overlap）用于判断是否有遮挡或目标在朝向范围内。
3.大致思路：
    动画时刻 + 距离+射线（推荐）：简单、稳健、对性能友好。
4.服务端权威
    所有判定都要在服务器做，客户端仅用于播放动画/特效。避免客户端直接调用 TakeDamage。
5.死亡通知与目标切换
    建议维护一个 UnitManager（或把所有活着的单位存在一个表里），当单位死亡时触发通知（事件/回调），攻击该单位的所有人会收到信号并重新 FindTarget()。
6.性能与并发注意
    AI 搜索频率不要过高（比如每 0.2–0.5 秒一次查找/更新目标）
    对场上单位做分组（按玩家/阵营）以减少不必要的遍历
    使用 Overlap 查询时，尽量用小频率/短时间窗来减少压力